#ifndef BENCHMARKS_H
#define BENCHMARKS_H

class Benchmarks
{
public:
    /*!
     * \brief Benchmarks the time taken to generate an icosphere.
     * This function will generate \p iterations icospheres for
     * each subdivisions < \p maxSubdivisions. The function
     * will then print the smallest time taken by the \p
     * iterations generations for each subdivision.
     * \param iterations The number of times the icosphere
     * will be generated in order to compute the best generation time.
     * \param maxIcosphereSubdivisions The maximum number of
     * subdivisions that will be used to generated the icosphere.
     * This corresponds to the number of subdivisions of the
     * icosphere itself.
     */
    static void BenchmarkIcosphere(int iterations, int maxIcosphereSubdivisions);

    /*!
     * \brief Benchmarks the time taken to generate a torus.
     * This function will generate \p iterations torus for
     * each subdivisions < \p maxSubdivisions. The function
     * will then print the smallest time taken by the \p
     * iterations generations for each subdivision.
     * \param iterations The number of times the torus
     * will be generated in order to compute the best generation time.
     * \param maxTorusSubdivisions The maximum number of
     * subdivisions that will be used to generated the torus.
     * This corresponds to the number of subdivisions of the
     * body of the torus.
     * \param ringCount The maximum number of ring count of the
     * torus to generate
     * \param ringSubdiv The maximum number of ring subdivisions
     * of the torus to generate
     * \param ringCountFixed If true, the \p ringCount parameter will
     * be fixed during the benchmark and only \p ringSubdiv will increase
     * up to \p maxTorusSubdivisions - 1. The tori generated by this
     * benchmark will thus have fixed ring counts but increasing
     * ringSubdivisions. Il false, it works the opposite way: ringSubdivisions
     * is fixed and \p maxTorusSubdivisions will increase up to \p ringCount - 1
     */
    static void BenchmarkTorus(int iterations, int maxTorusSubdivisions, int ringCount, int ringSubdiv, bool ringCountFixed);

    /*!
     * \brief Benchmarks the time taken to generate a capsule.
     * This function will generate \p iterations capsule for
     * each subdivisions < \p maxSubdivisions. The function
     * will then print the smallest time taken by the \p
     * iterations generations for each subdivision.
     * \param iterations The number of times the capsule
     * will be generated in order to compute the best generation time.
     * \param maxCapsuleSubdivisions The maximum number of
     * subdivisions that will be used to generated the capsule.
     * This corresponds to the number of subdivisions of the
     * body of the capsule.
     */
    static void BenchmarkCapsule(int iterations, int maxCapsuleSubdivisions);

    /*!
     * \brief Benchmarks the time taken to generate a cylinder.
     * This function will generate \p iterations cylinder for
     * each subdivisions < \p maxSubdivisions. The function
     * will then print the smallest time taken by the \p
     * iterations generations for each subdivision
     * \param iterations The number of times the cylinder
     * will be generated in order to compute the best generation time.
     * \param maxCylinderSubdivisions The maximum number of
     * subdivisions that will be used to generated the cylinder.
     * This corresponds to the number of subdivisions of the
     * body of the cylinder
     */
    static void BenchmarkCylinder(int iterations, int maxCylinderSubdivisions);

    /*!
     * \brief Benchmarks the time taken to compute the ambient
     * occlusion (accessibility) of a mesh when directly intersecting
     * with the mesh or when intersecting its analytic approximation.
     * \param iterations The mai
     */
    static void BenchmarkAOAnalyticVsMesh(unsigned int iterationsNonAnalytic, unsigned int iterationsAnalytic, unsigned int maxSubdivNonAnalytic, unsigned int maxSubdivAnalytic);

    /*!
     * \brief Benchmarks and prints to std::cout the number of
     * intersection tests done when intersecting a mesh with
     * and without a BVH.
     */
    static void BenchmarkBVHIntersectionCount();
};

#endif // BENCHMARKS_H
